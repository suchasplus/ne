# 模糊搜索功能设计文档 (Fuzzy Search Design Document)

本文档阐述了 `ne` 词典工具中模糊搜索功能的设计、算法选型、性能考量及最终架构决策。

## 1. 功能目标

当用户的搜索词在数据库中没有精确匹配时，系统应自动执行 Fuzzy Search (模糊搜索)，基于拼写相似度查找并推荐最可能的正确单词。该功能旨在处理常见的拼写错误，提升用户体验。

## 2. 核心算法：Levenshtein Distance (莱文斯坦距离)

Fuzzy Search 功能的核心是 **Levenshtein Distance** 算法。

-   **定义**: 两个字符串之间的 Levenshtein Distance 是指将一个字符串转换成另一个所需的最少单字符编辑次数。编辑操作包括：insertions (插入)、deletions (删除) 或 substitutions (替换)。
-   **选择原因**: 该算法是“编辑距离”领域的行业标准，能够完美地模拟常见的用户输入错误。
-   **实现**: 为确保正确性与性能，我们选择了一个成熟的 Go 语言库 `github.com/agnivade/levenshtein` 来进行实现。

## 3. 搜索方案的演进与选型

为了在一个包含60万词条的静态数据库中高效地实现 Fuzzy Search，我们评估了三种不同层次的��案。

### 方案一：智能线性扫描 (Implemented Solution)

这是一种在不改变现有数据库结构（KV存储）的前提下，通过在应用层实现智能排序和筛选来提供高质量建议的方案。

-   **核心机制**:
    1.  **距离筛选**: 使用 BoltDB 的游标 (`Cursor`) 遍历所有键，找出所有 Levenshtein 距离为 `1` 的单词。精确匹配（距离为 `0`）的单词会被忽略。
    2.  **性能优化 (长度剪枝)**: 在计算距离前，首先检查查询词与数据库中单词的长度差。如果长度差已经大于 `1`，则直接跳过该单词，避免了昂贵的距离计算。
    3.  **性能优化 (数量限制)**: 为了避免在输入非常模糊时（如单个字母）导致性能下降，当找到的候选词超过 `10` 个时，搜索会提前终止。

-   **智能排序**:
    对所有候选词进行排序，规则如下：
    1.  **主排序键**: 按**词频**排序。ECDICT 数据源中的 `frq` 字段值越**小**，代表词频越**高**。因此，按 `frq` 值**升序**排列。
    2.  **次排序键**: 如果词频相同，则按**单词长度**进行**降序**排列，优先选择更长的单词。

-   **结果裁剪**:
    -   如果排序后的建议列表包含 **3 个或更少**的单词，则返回全部建议。
    -   如果列表包含 **3 个以上**的单词，则只返回**前 3 个**（即词频最高/长度最长的前三个）。

-   **优点**:
    -   实现相对简单，无需修改数据库结构。
    -   通过智能排序和裁剪，提供了非常高质量的建议。
    -   性能对于处理常见的拼写错误已经足够好。
-   **缺点**:
    -   仍然需要物理遍历所有键，在最坏情况下性能有上限。
-   **结论**: 此方案在实现成本和用户体验之间取得了很好的平衡，因此被采纳并实现。

### 方案二：BK-Tree (理论最优的纯距离搜索方案)

这是一种专门为解决“最近邻搜索”问题而设计的高级方案���

-   **数据结构**: **BK-Tree (BK树)** 是一种基于距离度量构建的树。
-   **查询原理**: 利用 Metric Space (度量空间) 的 **Triangle Inequality (三角不等式)** 特性，可以高效地剪除大量不相关的搜索分支。
-   **优点**:
    -   **极致的查询性能**: 在纯粹的相似性搜索任务上，其性能是理论上的最优解。
-   **缺点**:
    -   **空间效率低下**: 每个节点存储完整的单词，导致索引体积巨大（预估 >150MB）。
    -   **功能极其单一**: **只能**用于相似性搜索，无法支持前缀匹配（自动补全）。

### 方案三：Trie 及其优化 Radix Tree (功能全面的高级方案)

这是一个兼顾了空间效率和功能多样性的高级方案。

-   **数据结构**: 标准的 **Trie (前缀树)** 通过共享前缀来存储字符串。在工程实践中，我们会使用其优化版本——**Radix Tree (紧凑型前缀树)** 或 Patricia Trie。Radix Tree 会将只有一个子节点的路径压缩成一条边，极大地减少了节点数量。
-   **查询原理**: 在 Trie/Radix Tree 上实现 Fuzzy Search 需要一个专门的递归算法，该算法在遍历树的同时，模拟四种编辑操作（匹配、替换、插入、删除）并进行剪枝。
-   **优点**:
    -   **高空间效率**: Radix Tree 通过压缩路径，使得节点数大大减少，其最终序列化后的大小与 BK-Tree 处于同一数量级（预估在 80-160MB 之间），甚至可能更小。
    -   **强大的功能多样性**: **这是 Trie/Radix Tree 的决定性优势**。一个数据结构可以同时高效地支持：
        1.  **精确匹配**
        2.  **前缀搜索 (自动补全功能)**
        3.  **模糊搜索 (拼写纠错)**
-   **缺点**:
    -   **模糊搜索算法更复杂**: 其递归实现比 BK-Tree 的查询更复杂。

## 4. 最终架构选型思考

**核心问题：在 Trie 和 BK-Tree 大小相当的情况下，如何选择？**

答案在于**机会成本**和**架构的未来价值**。

1.  **资源成本**: 两种高级方案都需要显著的存储和内存（约150MB）。它们的成本在同一水平线上。
2.  **功能回报**:
    -   花费 150MB，**BK-Tree** 只提供了一个功能：**极致的模糊搜索**。
    -   花费 150MB，**Radix Tree** 提供了三个功能：**优秀的模糊搜索**、**极致的前缀搜索**和**极致的精确匹配**。

**结论：Radix Tree 是更优越的工程选择。**

它用一份几乎相当的“资源成本”，换来了数倍的“功能回报”。选择 Radix Tree 是一个更具前瞻性的架构决策，它用一个统一、优雅的数据结构，为应用的现在和未来铺平了道路。如果未来需要增加“自动补全”功能，我们无需引入任何新的数据结构。

## 5. 最终决策：分阶段实施

基于以上分析，我们决定采用分阶段的实施方案：

1.  **第一阶段 (已实现)**: 使用**方案一（优化的线性扫描）**。它快速交付了核心功能，且性能在多数情况下可以接受。
2.  **第二阶段 (未来工作)**: 当需要追求极致性能时，应**优先采用方案三（Radix Tree）**。届时，`kvbuilder` 将负责构建并序列化 Radix Tree 存入 BoltDB，而 `ne` 则加载它来执行包括模糊搜索在内的多种查询。