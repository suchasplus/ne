# 模糊搜索功能设计文档

本文档阐述了 `ne` 词典工具中模糊搜索功能的设计与实现策略。

## 1. 功能目标

当用户的搜索词在数据库中没有精确匹配时，系统应自动执行 Fuzzy Search (模糊搜索)，基于拼写相似度查找并推荐最可能的正确单词。该功能旨在处理常见的拼写错误，提升用户体验。

## 2. 核心算法：Levenshtein Distance (莱文斯坦距离)

Fuzzy Search 功能的核心是 **Levenshtein Distance** 算法。

-   **定义**: 两个字符串之间的 Levenshtein Distance 是指将一个字符串转换成另一个所需的最少单字符编辑次数。编辑操作包括：insertions (插入)、deletions (删除) 或 substitutions (替换)。
-   **选择原因**: 该算法是“编辑距离”领域的行业标准，能够完美地模拟常见的用户输入错误，例如：
    -   **Insertion**: `devlop` → `develop` (1次编辑)
    -   **Substitution**: `devrlop` → `develop` (1次编辑)
    -   **Deletion**: `develo` → `develop` (1次编辑)
-   **实现**: 为确保正确性与性能，我们选择了一个成熟的 Go 语言库 `github.com/agnivade/levenshtein` 来进行实现。

## 3. 实现策略与效率优化

在一个包含数十万词条的数据库中，逐一计算 Levenshtein Distance 的暴力法过于缓慢。为了在短期方案中保证可接受的性能，我们实现了以下优化。

### 3.1. Length Pruning (长度剪枝)

-   **逻辑**: 这是一个高效的预过滤步骤。如果两个字符串的长度之差大于允许的最大 Levenshtein Distance，那么它们实际的 Levenshtein Distance 也必然大于该阈值。
-   **示例**: 如果我们想为 `devlop` (长度6) 查找最大距离为 `2` 的相似词，那么任何长度小于 `4` (6-2) 或大于 `8` (6+2) 的单词都可以被安全地跳过，无需进行昂贵的距离计算。
-   **效果**: 极大地减少了需要被完整评估的候选词数量。

### 3.2. Dynamic Threshold Adjustment (动态阈值调整)

-   **逻辑**: 此优化旨在尽快找到*最佳*匹配。搜索从一个预设的最大距离（如 `2`）开始。如果找到了一个距离为 `1` 的匹配项，那么 `1` 就成为后续所有比较的新的最大距离。
-   **示例**: 当搜索 `aply` (最大距离为2) 时，算法可能先找到了 `apple` (距离2)。随后，它又找到了 `apply` (距离1)。此时，`bestDistance` 会被更新为 `1`，候选列表也被重置为仅包含 `["apply"]`。任何后续计算出的��离大于 `1` 的候选词都将被忽略。
-   **效果**: 确保一旦找到非常接近的匹配，算法就不会再浪费时间评估可能性更低的候选词，从而更快地得出结论。

## 4. 长期高性能解决方案：BK-Tree (BK树)

为了实现极致性能，特别是在当前方案被证明不够用的情况下，推荐使用更高级的数据结构。

-   **定义**: **BK-Tree** 是一种专门为在 Metric Space (度量空间) 中进行高效相似性搜索而设计的树状数据结构。每个节点是一个单词，其子节点根据与父节点的 Levenshtein Distance 被划分到不同的分支。
-   **工作原理**: 搜索时，通过计算查询词与当前节点的距离 `d` 来遍历树。它利用 Metric Space 的 **Triangle Inequality (三角不等式)** 特性，只探索那些与父节点距离 `d'` 在 `[d - maxDistance, d + maxDistance]` 范围内的子分支，从而智能地剪除树的大部分分支，避免了全库扫描。
-   **预估大小**: 对于 `ne` 项目约60万单词的词典，一个序列化后的 BK-Tree 索引大小预估在 **100-200 MB** 之间。
-   **权衡**:
    -   **优点**: 提供近乎即时的 Fuzzy Search 结果 (`O(log N)` 复杂度)。
    -   **缺点**: 显著增加数据库文件体积，并在执行模糊搜索时需要更多内存，因为整个树必须被加载到内存中。

## 5. 最终决策：分阶段实施

基于以上分析，我们决定采用分阶段的实施方案：

1.  **第一阶段 (已实现)**: 使用 **Levenshtein Distance 算法，并结合 Length Pruning 和 Dynamic Threshold Adjustment 优化**，交付一个健壮且速度合理的解决方案。这可以在不显著增加项目复杂度或资源需求的前提下，快速提供核心功能。
2.  **第二阶段 (未来工作)**: 如果第一阶段的方案在实际使用中性能不足，则实施 **BK-Tree** 方案。届时，一个可行的优化策略是仅对最高频的一部分单词建立索引，以控制索引大小和内存占用。
